/*
 * Copyright 2017 Igor Maznitsa.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.igormaznitsa.jbbp.compiler.utils.converter;

import com.igormaznitsa.jbbp.JBBPParser;
import com.igormaznitsa.jbbp.compiler.JBBPCompiledBlock;
import com.igormaznitsa.jbbp.compiler.JBBPCompiler;
import com.igormaznitsa.jbbp.compiler.JBBPNamedFieldInfo;
import com.igormaznitsa.jbbp.compiler.tokenizer.JBBPFieldTypeParameterContainer;
import com.igormaznitsa.jbbp.compiler.varlen.JBBPIntegerValueEvaluator;
import com.igormaznitsa.jbbp.io.JBBPBitInputStream;
import com.igormaznitsa.jbbp.io.JBBPBitNumber;
import com.igormaznitsa.jbbp.io.JBBPByteOrder;
import com.igormaznitsa.jbbp.utils.JBBPUtils;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class ParserToJavaClass extends AbstractCompiledBlockConverter<ParserToJavaClass> {

    private static final String TEMPLATE;

    static {
        JBBPBitInputStream stream = null;
        try {
            stream = new JBBPBitInputStream(ParserToJavaClass.class.getResourceAsStream("/templates/template_java_class.txt"));
            TEMPLATE = new String(stream.readByteArray(-1), "UTF-8");
        } catch (IOException ex) {
            throw new Error("Can't load template", ex);
        } finally {
            JBBPUtils.closeQuietly(stream);
        }
    }

    private final String packageName;
    private final String className;
    private final TextBuffer methods = new TextBuffer();
    private final TextBuffer mainFields = new TextBuffer();
    private final TextBuffer readFieldsBody = new TextBuffer();
    private final TextBuffer classComments = new TextBuffer();
    private final List<TextBuffer> embeddedClasses = new ArrayList<TextBuffer>();
    private TextBuffer currentInsideClass;
    private final String extraMethods;
    private boolean detectedCustomFields;
    private boolean detectedVarFields;
    private final AtomicInteger anonymousFieldCounter = new AtomicInteger();

    private String result;

    public ParserToJavaClass(final String packageName, final String className, final JBBPParser notNullParser, final String nullableExtraMethods) {
        this(packageName, className, notNullParser.getCompiledBlock(), nullableExtraMethods);
    }

    public ParserToJavaClass(final String packageName, final String className, final JBBPCompiledBlock notNullCompiledBlock, final String nullableExtraMethods) {
        super(notNullCompiledBlock);
        this.packageName = packageName;
        this.className = className;
        this.extraMethods = nullableExtraMethods == null ? "" : nullableExtraMethods;
    }

    @Override
    public void onConvertStart() {
        this.embeddedClasses.clear();
        this.currentInsideClass = null;
        this.detectedCustomFields = false;
        this.detectedVarFields = false;
        this.anonymousFieldCounter.set(1);
        this.classComments.print("// Generated by ").print(ParserToJavaClass.class.getName());
    }

    public String getResult() {
        return this.result;
    }

    @Override
    public void onConvertEnd() {
        this.result = TEMPLATE
                .replace("${readFieldsBody}", this.readFieldsBody.toStringAndClean(4))
                .replace("${methods}", this.methods.toStringAndClean(4))
                .replace("${extraMethods}", this.extraMethods)
                .replace("${className}", this.className)
                .replace("${classComments}", this.classComments.toStringAndClean(4))
                .replace("${mainFields}", this.mainFields.toStringAndClean(2))
                .replace("${packageName}", this.packageName);
    }

    @Override
    public void onStructStart(final int offsetInCompiledBlock, final JBBPNamedFieldInfo nullableNameFieldInfo, final JBBPIntegerValueEvaluator nullableArraySize) {

    }

    @Override
    public void onStructEnd(final int offsetInCompiledBlock, final JBBPNamedFieldInfo nullableNameFieldInfo) {

    }

    @Override
    public void onBitField(final int offsetInCompiledBlock, final JBBPNamedFieldInfo nullableNameFieldInfo, final JBBPIntegerValueEvaluator notNullFieldSize, final JBBPIntegerValueEvaluator nullableArraySize) {
        TextBuffer fieldOut = this.currentInsideClass == null ? this.mainFields : this.currentInsideClass;

        final String fieldName = nullableNameFieldInfo == null ? "_afield" + anonymousFieldCounter.getAndIncrement() : nullableNameFieldInfo.getFieldName();
        final String javaFieldType = "byte";

        String sizeOfField = evaluatorToString(offsetInCompiledBlock, notNullFieldSize);
        try{
            sizeOfField = "JBBPBitNumber."+JBBPBitNumber.decode(Integer.parseInt(sizeOfField)).name();
        }catch(NumberFormatException ex){
            sizeOfField = "JBBPBitNumber.decode("+sizeOfField+')';
        }


        final String arraySize = nullableArraySize == null ? null : evaluatorToString(offsetInCompiledBlock, nullableArraySize);

        final String fieldModifier;
        if (nullableNameFieldInfo == null) {
            fieldModifier = "protected ";
        } else {
            fieldModifier = "public ";
        }

        if (arraySize == null) {
            this.readFieldsBody.print(fieldName).print(" = theStream.readBitField(").print(sizeOfField).println(");");
        } else {
            this.readFieldsBody.print(fieldName).print(" = theStream.readBitsArray(").print(arraySize).print(",").print(sizeOfField).println(");");
        }

        fieldOut.println(nullableNameFieldInfo == null ? "// an anonymous field" : "// the named field '" + nullableNameFieldInfo.getFieldName() + '\'');
        fieldOut.print(fieldModifier).print(javaFieldType).print(" ").print(nullableArraySize == null ? "" : "[] ").print(fieldName).println(";").println();

    }

    @Override
    public void onCustom(final int offsetInCompiledBlock, final JBBPFieldTypeParameterContainer notNullfieldType, final JBBPNamedFieldInfo nullableNameFieldInfo, final JBBPByteOrder byteOrder, final JBBPIntegerValueEvaluator nullableArraySize) {
        this.detectedCustomFields = true;
    }

    @Override
    public void onVar(final int offsetInCompiledBlock, final JBBPNamedFieldInfo nullableNameFieldInfo, final JBBPByteOrder byteOrder, final JBBPIntegerValueEvaluator nullableArraySize) {
        this.detectedVarFields = true;
    }

    private String evaluatorToString(final int offsetInBlock, final JBBPIntegerValueEvaluator evaluator) {
        final StringBuilder buffer = new StringBuilder();

        final ExpressionEvaluatorVisitor visitor = new ExpressionEvaluatorVisitor() {
            private final List<Object> stack = new ArrayList<Object>();

            @Override
            public ExpressionEvaluatorVisitor begin() {
                this.stack.clear();
                return this;
            }

            @Override
            public ExpressionEvaluatorVisitor visit(final Special specialField) {
                stack.add(specialField);
                return this;
            }

            @Override
            public ExpressionEvaluatorVisitor visit(final JBBPNamedFieldInfo nullableNameFieldInfo, final String nullableExternalFieldName) {
                if (nullableNameFieldInfo != null) {
                    this.stack.add(nullableNameFieldInfo);
                } else if (nullableExternalFieldName!= null) {
                    this.stack.add(nullableExternalFieldName);
                }
                return this;
            }

            @Override
            public ExpressionEvaluatorVisitor visit(final Operator operator) {
                this.stack.add(operator);
                return this;
            }

            @Override
            public ExpressionEvaluatorVisitor visit(final int value) {
                this.stack.add(value);
                return this;
            }

            @Override
            public ExpressionEvaluatorVisitor end() {
                // process operators
                for(int i=0;i<this.stack.size();i++) {
                }

                // process rest
                for(final Object obj : this.stack) {
                    if (obj instanceof Special) {
                        switch((Special)obj){
                            case STREAM_COUNTER: buffer.append("(int)theStream.getCounter()");break;
                            default: throw new Error("Unexpected special type:"+obj);
                        }
                    } else
                    if (obj instanceof Integer) {
                        buffer.append(obj.toString());
                    } else if (obj instanceof JBBPNamedFieldInfo) {

                    } else if (obj instanceof String) {

                    } else throw new Error("Unexpected item");
                }

                return this;
            }
        };

        evaluator.visit(this.compiledBlock, offsetInBlock, visitor);

        return buffer.toString();
    }

    @Override
    public void onPrimitive(final int offsetInCompiledBlock, final int primitiveType, final JBBPNamedFieldInfo nullableNameFieldInfo, final JBBPByteOrder byteOrder, final JBBPIntegerValueEvaluator nullableArraySize) {
        TextBuffer fieldOut = this.currentInsideClass == null ? this.mainFields : this.currentInsideClass;

        final String fieldName = nullableNameFieldInfo == null ? "_afield" + anonymousFieldCounter.getAndIncrement() : nullableNameFieldInfo.getFieldName();
        final String javaFieldType;

        final String arraySize = nullableArraySize == null ? null : evaluatorToString(offsetInCompiledBlock, nullableArraySize);

        switch (primitiveType) {
            case JBBPCompiler.CODE_BOOL: {
                javaFieldType = "boolean";
                if (arraySize == null) {
                    this.readFieldsBody.print(fieldName).println(" = theStream.readBoolean();");
                } else {
                    this.readFieldsBody.print(fieldName).print(" = theStream.readBoolArray(").print(arraySize).println(");");
                }
            }
            break;
            case JBBPCompiler.CODE_BYTE:
            case JBBPCompiler.CODE_UBYTE: {
                javaFieldType = "byte";
                if (arraySize == null) {
                    this.readFieldsBody.print(fieldName).println(" = (byte) theStream.readByte();");
                } else {
                    this.readFieldsBody.print(fieldName).print(" = theStream.readByteArray(").print(arraySize).println(");");
                    if (byteOrder == JBBPByteOrder.LITTLE_ENDIAN) {
                        this.readFieldsBody.print("JBBPUtils.reverseArray(").print(fieldName).println(");");
                    }
                }
            }
            break;
            case JBBPCompiler.CODE_INT: {
                javaFieldType = "int";
                if (arraySize == null) {
                    this.readFieldsBody.print(fieldName).print(" = theStream.readInt(JBBPByteOrder.").print(byteOrder.name()).println(");");
                } else {
                    this.readFieldsBody.print(fieldName).print(" = theStream.readIntArray(").print(arraySize).print(",JBBPByteOrder.").print(byteOrder.name()).println(");");
                }
            }
            break;
            case JBBPCompiler.CODE_USHORT:
            case JBBPCompiler.CODE_SHORT: {
                javaFieldType = "short";
                if (arraySize == null) {
                    this.readFieldsBody.print(fieldName).print(" = (short)theStream.readUnsignedShort(JBBPByteOrder.").print(byteOrder.name()).println(");");
                } else {
                    this.readFieldsBody.print(fieldName).print(" = theStream.readShortArray(").print(arraySize).print(",JBBPByteOrder.").print(byteOrder.name()).println(");");
                }
            }
            break;
            case JBBPCompiler.CODE_LONG: {
                javaFieldType = "long";
                if (arraySize == null) {
                    this.readFieldsBody.print(fieldName).print(" = theStream.readLong(JBBPByteOrder.").print(byteOrder.name()).println(");");
                } else {
                    this.readFieldsBody.print(fieldName).print(" = theStream.readLongArray(").print(arraySize).print(",JBBPByteOrder.").print(byteOrder.name()).println(");");
                }
            }
            break;
            default:
                throw new Error("Unexpected primitive type, contact developer : " + primitiveType);
        }

        final String fieldModifier;
        if (nullableNameFieldInfo == null) {
            fieldModifier = "protected ";
        } else {
            fieldModifier = "public ";
        }

        fieldOut.println(nullableNameFieldInfo == null ? "// an anonymous field" : "// the named field '" + nullableNameFieldInfo.getFieldName() + '\'');
        fieldOut.print(fieldModifier).print(javaFieldType).print(" ").print(nullableArraySize == null ? "" : "[] ").print(fieldName).println(";").println();
    }

    @Override
    public void onActionItem(final int offsetInCompiledBlock, final int actionType, final JBBPIntegerValueEvaluator nullableArgument) {
        final String valueTxt = nullableArgument == null ? null : evaluatorToString(offsetInCompiledBlock, nullableArgument);

        switch (actionType) {
            case JBBPCompiler.CODE_RESET_COUNTER: {
                this.readFieldsBody.println("theStream.resetCounter();");
            }
            break;
            case JBBPCompiler.CODE_ALIGN: {
                this.readFieldsBody.print("theStream.align(").print(valueTxt).println(");");
            }
            break;
            case JBBPCompiler.CODE_SKIP: {
                this.readFieldsBody.print("theStream.skip(").print(valueTxt).println(");");
            }
            break;
            default: {
                throw new Error("Detected unknown action, contact developer!");
            }
        }
    }

}
